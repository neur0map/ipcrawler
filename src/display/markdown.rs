use crate::parser::ExtractedEntities;
use crate::storage::{OutputManager, ScanReport};
use anyhow::Result;
use tokio::fs;

pub struct MarkdownReport;

impl MarkdownReport {
    pub async fn generate(report: &ScanReport, entities: &ExtractedEntities, output_manager: &OutputManager) -> Result<()> {
        let markdown = Self::build_markdown(report, entities);
        let report_path = output_manager.get_markdown_report_file();
        
        fs::write(&report_path, markdown).await?;
        
        println!("Markdown report saved: {}", report_path.display());
        Ok(())
    }

    fn build_markdown(report: &ScanReport, entities: &ExtractedEntities) -> String {
        format!(
            r#"# 🎯 IPCrawler Security Scan Report

## Target: {}

**Scan Date:** {}  
**Duration:** {} seconds  
**Tools Executed:** {}/{}  

---

{}

{}

{}

{}

{}

{}

{}

---

## 🔧 Tools Executed

{}

---

*Generated by IPCrawler - Intelligent Penetration Testing Scanner*
"#,
            report.target,
            report.start_time.format("%Y-%m-%d %H:%M:%S UTC"),
            report.duration,
            report.summary.successful_tools,
            report.summary.total_tools,
            Self::build_summary(report),
            Self::build_vulnerabilities(&entities.vulnerabilities),
            Self::build_ports(&entities.ports),
            Self::build_urls(&entities.urls),
            Self::build_ips(&entities.ips),
            Self::build_domains(&entities.domains),
            Self::build_findings(&entities.findings),
            Self::build_tools(&report.tools_executed),
        )
    }

    fn build_summary(report: &ScanReport) -> String {
        format!(
            r#"## 📊 Summary

| Metric | Count |
|--------|-------|
| IPs Found | {} |
| Domains Found | {} |
| URLs Found | {} |
| Open Ports | {} |
| Vulnerabilities | {} |
| Other Findings | {} |"#,
            report.summary.total_ips,
            report.summary.total_domains,
            report.summary.total_urls,
            report.summary.total_ports,
            report.summary.total_vulnerabilities,
            report.entities.findings.len(),
        )
    }

    fn build_vulnerabilities(vulns: &[crate::parser::Vulnerability]) -> String {
        if vulns.is_empty() {
            return "## ✅ Vulnerabilities\n\nNo vulnerabilities detected.".to_string();
        }

        let mut md = format!("## ⚠️ Vulnerabilities ({})\n\n", vulns.len());

        for (i, vuln) in vulns.iter().enumerate() {
            let severity_emoji = match vuln.severity.to_lowercase().as_str() {
                "critical" => "🔴",
                "high" => "🟠",
                "medium" => "🟡",
                "low" => "🟢",
                _ => "⚪",
            };

            md.push_str(&format!(
                "### {}. {} {} [{}]\n\n{}\n\n",
                i + 1,
                severity_emoji,
                vuln.name,
                vuln.severity.to_uppercase(),
                vuln.description
            ));
        }

        md
    }

    fn build_ports(ports: &[crate::parser::PortInfo]) -> String {
        if ports.is_empty() {
            return String::new();
        }

        let mut md = format!("## 🔌 Open Ports ({})\n\n", ports.len());
        md.push_str("| Port | Protocol | Service | Version |\n");
        md.push_str("|------|----------|---------|----------|\n");

        for port in ports {
            md.push_str(&format!(
                "| {} | {} | {} | {} |\n",
                port.port,
                port.protocol,
                port.service.as_deref().unwrap_or("unknown"),
                port.version.as_deref().unwrap_or("-")
            ));
        }

        md.push('\n');
        md
    }

    fn build_urls(urls: &[String]) -> String {
        if urls.is_empty() {
            return String::new();
        }

        let mut md = format!("## 🌍 URLs Found ({})\n\n", urls.len());

        for (i, url) in urls.iter().enumerate() {
            md.push_str(&format!("{}. <{}>\n", i + 1, url));
        }

        md.push('\n');
        md
    }

    fn build_ips(ips: &[String]) -> String {
        if ips.is_empty() {
            return String::new();
        }

        let mut md = format!("## 🌐 IP Addresses ({})\n\n", ips.len());

        for (i, ip) in ips.iter().enumerate() {
            md.push_str(&format!("{}. `{}`\n", i + 1, ip));
        }

        md.push('\n');
        md
    }

    fn build_domains(domains: &[String]) -> String {
        if domains.is_empty() {
            return String::new();
        }

        let mut md = format!("## 🔗 Domains ({})\n\n", domains.len());

        for (i, domain) in domains.iter().enumerate() {
            md.push_str(&format!("{}. `{}`\n", i + 1, domain));
        }

        md.push('\n');
        md
    }

    fn build_findings(findings: &[String]) -> String {
        if findings.is_empty() {
            return String::new();
        }

        let mut md = format!("## 📋 Other Findings ({})\n\n", findings.len());

        for (i, finding) in findings.iter().enumerate() {
            md.push_str(&format!("{}. {}\n", i + 1, finding));
        }

        md.push('\n');
        md
    }

    fn build_tools(tools: &[crate::storage::ToolExecution]) -> String {
        let mut md = String::from("| Tool | Status | Duration |\n");
        md.push_str("|------|--------|----------|\n");

        for tool in tools {
            let status = if tool.success { "✅ Success" } else { "❌ Failed" };
            md.push_str(&format!(
                "| {} | {} | {:.2}s |\n",
                tool.name, status, tool.duration_secs
            ));
        }

        md
    }
}
