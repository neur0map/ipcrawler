use anyhow::Result;
use colored::Colorize;
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use tera::{Tera, Context as TeraContext};
use uuid::Uuid;

use crate::output::OutputManager;
use crate::template::ToolTemplate;

#[derive(Debug, Serialize, Deserialize)]
pub struct ToolResult {
    pub template: ToolTemplate,
    pub target: String,
    pub success: bool,
    pub output_file: String,
    pub executed_at: DateTime<Utc>,
    pub output_content: String,
}

#[derive(Debug, Serialize)]
pub struct ExecutionSummary {
    pub targets: Vec<String>,
    pub total_tools: usize,
    pub successful_executions: usize,
    pub failed_executions: usize,
    pub execution_time: chrono::Duration,
    pub started_at: DateTime<Utc>,
    pub completed_at: DateTime<Utc>,
}

pub struct ReportGenerator {
    output_manager: OutputManager,
    tera: Tera,
}

impl ReportGenerator {
    pub fn new(output_dir: &str) -> Result<Self> {
        let mut tera = Tera::default();
        tera.add_raw_template(
            "summary.md",
            r#"
# IPCrawler Report

**Generated:** {{ timestamp | date(format="%Y-%m-%d %H:%M:%S UTC") }}
**Targets:** {{ targets | join(sep=", ") }}
**Execution Time:** {{ execution_time }}

## Executive Summary

- Total Tools Executed: {{ total_tools }}
- Successful Executions: {{ successful_executions }}
- Failed Executions: {{ failed_executions }}
- Success Rate: {{ success_rate }}%

## Tool Categories

{% for category, tools in results_by_category %}
### {{ category | title }}

{% for tool_result in tools %}
- **{{ tool_result.template.name }}** - {{ tool_result.target }}
  {% if tool_result.success %}‚úÖ{% else %}‚ùå{% endif %}
{% endfor %}

{% endfor %}

## Raw Output Files

All raw output files are available in the `raw/` directory:
{% for result in all_results %}
- `raw/{{ result.output_file }}` - {{ result.template.name }} ({{ result.target }})
{% endfor %}

---
*Generated by IPCrawler v0.1.0*
"#
        )?;
        
        tera.add_raw_template(
            "detailed.md",
            r#"
# Detailed IPCrawler Report

**Generated:** {{ timestamp | date(format="%Y-%m-%d %H:%M:%S UTC") }}
**Targets:** {{ targets | join(sep=", ") }}

{% for result in all_results %}
# {{ result.template.name }} - {{ result.target }}

**Category:** {{ result.template.category }}
**Description:** {{ result.template.description }}
**Executed:** {{ result.executed_at | date(format="%Y-%m-%d %H:%M:%S UTC") }}
**Status:** {% if result.success %}‚úÖ Success{% else %}‚ùå Failed{% endif %}

**Command:** `{{ result.template.command }}{% for arg in result.template.args %} {{ arg | replace(from="{target}", to=result.target) }}{% endfor %}`

## Output
```
{{ result.output_content }}
```

---

{% endfor %}

---
*Generated by IPCrawler v0.1.0*
"#
        )?;
        
        Ok(ReportGenerator {
            output_manager: OutputManager::new(output_dir)?,
            tera,
        })
    }
    
    pub async fn generate_reports(&self, results: Vec<tokio::task::JoinHandle<(ToolTemplate, String, Result<()>)>>) -> Result<()> {
        let mut all_results = Vec::new();
        let mut successful = 0;
        let mut failed = 0;
        
        let started_at = Utc::now();
        
        // Collect results
        for handle in results {
            match handle.await {
                Ok((template, target, execution_result)) => {
                    let success = execution_result.is_ok();
                    if success {
                        successful += 1;
                    } else {
                        failed += 1;
                    }
                    
                    let output_file = template.output_file
                        .as_ref()
                        .map(|f| f.replace("{target}", &target))
                        .unwrap_or_else(|| format!("{}.txt", Uuid::new_v4()));
                    
                    // Read the output for detailed report
                    let output_content = if success {
                        tokio::fs::read_to_string(self.output_manager.get_raw_output_path(&output_file)).await
                            .unwrap_or_default()
                    } else {
                        execution_result.unwrap_err().to_string()
                    };
                    
                    all_results.push(ToolResult {
                        template,
                        target,
                        success,
                        output_file,
                        executed_at: Utc::now(),
                        output_content,
                    });
                }
                Err(e) => {
                    eprintln!("Error collecting result: {}", e);
                    failed += 1;
                }
            }
        }
        
        let completed_at = Utc::now();
        
        // Group results by category
        let mut results_by_category: HashMap<String, Vec<&ToolResult>> = HashMap::new();
        let mut targets = std::collections::HashSet::new();
        
        for result in &all_results {
            targets.insert(result.target.clone());
            results_by_category
                .entry(result.template.category.clone())
                .or_default()
                .push(result);
        }
        
        // Create summary report
        let mut context = TeraContext::new();
        context.insert("timestamp", &Utc::now());
        context.insert("targets", &targets.into_iter().collect::<Vec<_>>());
        context.insert("total_tools", &all_results.len());
        context.insert("successful_executions", &successful);
        context.insert("failed_executions", &failed);
        context.insert("success_rate", &((successful as f64 / all_results.len() as f64) * 100.0));
        context.insert("execution_time", &(completed_at - started_at));
        context.insert("results_by_category", &results_by_category);
        context.insert("all_results", &all_results);
        
        let summary_report = self.tera.render("summary.md", &context)?;
        let detailed_report = self.tera.render("detailed.md", &context)?;
        
        // Save reports
        let timestamp = Utc::now().format("%Y%m%d_%H%M%S");
        
        self.output_manager.save_report(
            &format!("ipcrawler_summary_{}.md", timestamp),
            &summary_report
        ).await?;
        
        self.output_manager.save_report(
            &format!("ipcrawler_detailed_{}.md", timestamp),
            &detailed_report
        ).await?;
        
        println!("{} Summary report: reports/ipcrawler_summary_{}.md", "üìÑ".blue(), timestamp);
        println!("{} Detailed report: reports/ipcrawler_detailed_{}.md", "üìÑ".blue(), timestamp);
        
        Ok(())
    }
}
