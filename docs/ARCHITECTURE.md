# IPCrawler Architecture

Technical implementation details for developers.

## Overview

IPCrawler is a Rust-based automated penetration testing scanner that intelligently executes security tools and uses LLMs to parse outputs without hardcoded regex patterns.

## Design Principles

1. **No Hardcoded Regex**: Use ML/LLM for intelligent output parsing
2. **Async Everything**: Tokio-based concurrent execution
3. **YAML Configuration**: Tool definitions in simple YAML files
4. **Smart Privilege Detection**: Automatic sudo vs non-sudo template selection
5. **Extensible**: Easy to add new tools via YAML templates

## Project Structure

```
ipcrawler/
├── src/
│   ├── main.rs              # Entry point & orchestration
│   ├── cli.rs               # Command-line argument parsing
│   ├── templates/           # Template system
│   │   ├── mod.rs
│   │   ├── models.rs        # Template data structures
│   │   ├── parser.rs        # YAML template loader
│   │   ├── selector.rs      # Smart template selection logic
│   │   └── executor.rs      # Async tool execution engine
│   ├── parser/              # ML-based output parsing
│   │   ├── mod.rs
│   │   ├── llm.rs           # LLM API integrations
│   │   └── extractor.rs     # Entity extraction & merging
│   └── storage/             # Output management
│       ├── mod.rs
│       ├── output.rs        # File system operations
│       └── report.rs        # Report generation
└── templates/               # YAML tool definitions
    ├── nmap.yaml
    ├── nmap-sudo.yaml
    └── ...
```

## Core Components

### 1. CLI Module (`src/cli.rs`)

**Purpose**: Parse command-line arguments

**Key Features**:
- Target and output path validation
- LLM provider/model configuration
- Subcommands: `list`, `show`

**Dependencies**: `clap` with derive macros

### 2. Template System (`src/templates/`)

#### 2.1 Models (`models.rs`)

Defines template structure:
```rust
pub struct Template {
    pub name: String,
    pub description: String,
    pub enabled: Option<bool>,
    pub command: TemplateCommand,
    pub timeout: Option<u64>,
    pub requires_sudo: Option<bool>,
    // ...
}
```

#### 2.2 Parser (`parser.rs`)

**Purpose**: Load and parse YAML templates

**Key Methods**:
- `load_all()`: Scan templates directory
- `load_template()`: Parse single YAML file
- `find_template()`: Locate specific template

#### 2.3 Selector (`selector.rs`)

**Purpose**: Smart template selection based on privilege level

**Logic**:
```
If running as sudo:
  1. Prefer templates ending with -sudo
  2. Use regular templates if no sudo variant exists
  3. Skip templates with requires_sudo: true if not root

If running as regular user:
  1. Use regular templates only
  2. Skip -sudo variants
  3. Skip requires_sudo: true templates
```

**Platform Support**:
- Unix: Uses `libc::geteuid()`
- Windows: Always returns false (no sudo concept)

#### 2.4 Executor (`executor.rs`)

**Purpose**: Async tool execution with Tokio

**Key Features**:
- Timeout handling
- stdout/stderr capture
- Tool-not-found detection
- Output file creation

**Execution Flow**:
```
1. Interpolate {{target}} and {{output_dir}} in args
2. Create output directory
3. Spawn async process with timeout
4. Capture stdout/stderr
5. Write to output file
6. Return ExecutionResult
```

### 3. Parser Module (`src/parser/`)

#### 3.1 LLM Integration (`llm.rs`)

**Supported Providers**:
- **OpenAI**: GPT-4, GPT-3.5
- **Anthropic**: Claude models
- **Ollama**: Local models (llama, mistral, etc.)

**Request Flow**:
```
1. Build extraction prompt with scan output
2. Send to LLM API
3. Receive JSON response
4. Return parsed text
```

**Prompt Design**:
```
Input: Tool output (up to 50KB)
Task: Extract structured entities as JSON
Output: {ips, domains, urls, ports, vulnerabilities, findings}
```

#### 3.2 Entity Extractor (`extractor.rs`)

**Purpose**: Parse LLM responses and merge results

**Data Structures**:
```rust
pub struct ExtractedEntities {
    pub ips: Vec<String>,
    pub domains: Vec<String>,
    pub urls: Vec<String>,
    pub ports: Vec<PortInfo>,
    pub vulnerabilities: Vec<Vulnerability>,
    pub findings: Vec<String>,
}
```

**Key Methods**:
- `extract()`: Parse single tool output via LLM
- `merge_entities()`: Combine results from all tools
- `extract_json()`: Handle various JSON formatting

### 4. Storage Module (`src/storage/`)

#### 4.1 Output Manager (`output.rs`)

**Purpose**: Manage file system structure

**Directory Layout**:
```
output_dir/
├── raw/                 # Created by OutputManager
│   └── {tool_name}/    # Created by Executor
│       └── outputs...
├── entities.json       # Generated by ReportManager
└── report.json         # Generated by ReportManager
```

#### 4.2 Report Manager (`report.rs`)

**Purpose**: Generate final reports

**Report Types**:

1. **Scan Report** (`report.json`):
   - Metadata (target, timestamps, duration)
   - Tool execution results
   - Summary statistics

2. **Entities** (`entities.json`):
   - Deduplicated IPs, domains, URLs
   - Port information
   - Vulnerabilities
   - Security findings

## Data Flow

```
1. User Command
   ↓
2. CLI Parsing (cli.rs)
   ↓
3. Template Loading (parser.rs)
   ↓
4. Template Selection (selector.rs)
   ↓
5. Tool Execution (executor.rs) [Async/Concurrent]
   ↓
6. Output Capture & Storage (output.rs)
   ↓
7. LLM Parsing (llm.rs) [Optional]
   ↓
8. Entity Extraction (extractor.rs)
   ↓
9. Entity Merging (extractor.rs)
   ↓
10. Report Generation (report.rs)
    ↓
11. Display Summary (main.rs)
```

## Concurrency Model

- **Runtime**: Tokio async runtime
- **Execution**: Sequential template execution (prevents resource conflicts)
- **I/O**: Async file operations
- **Future Enhancement**: Parallel execution with dependency resolution

## Error Handling

**Strategy**: Anyhow for error propagation with context

**Levels**:
1. **Fatal**: CLI validation, template loading
2. **Recoverable**: Tool execution failures, LLM errors
3. **Warnings**: Missing tools, LLM parsing failures

**Example**:
```rust
let template = parser.load_template(&path)
    .with_context(|| format!("Failed to load template: {}", path.display()))?;
```

## Configuration

### Template Configuration

YAML files in `templates/` directory:
```yaml
name: tool-name
description: Tool description
enabled: true
command:
  binary: executable
  args: ["arg1", "{{target}}"]
timeout: 600
requires_sudo: false
```

### LLM Configuration

Environment variables or CLI args:
```bash
LLM_API_KEY=sk-...              # API key
--llm-provider=openai           # Provider selection
--llm-model=gpt-4              # Model override
```

## Extension Points

### Adding New Tools

1. Create YAML template in `templates/`
2. Test with `ipcrawler show tool-name`
3. Enable with `enabled: true`

### Adding LLM Providers

1. Add variant to `LlmProvider` enum
2. Implement API call method
3. Update provider parsing logic

### Custom Output Formats

1. Extend `ExtractedEntities` struct
2. Update LLM prompt
3. Modify report generation

## Performance Considerations

### Memory
- Large outputs truncated to 50KB for LLM
- Streaming not implemented (future enhancement)

### Network
- LLM calls are sequential
- Rate limiting handled by provider

### Disk I/O
- Async file operations
- Output buffering via tokio::fs

## Security Considerations

### Privilege Escalation
- Explicit sudo detection
- No automatic privilege elevation
- Clear sudo requirement in templates

### Input Validation
- Target sanitization for filenames
- YAML schema validation
- Command injection prevention via array args

### Output Sanitization
- No execution of captured output
- Secure file path handling
- Sensitive data warnings (future)

## Testing Strategy

**Current**:
- Manual testing via examples
- Template validation on load

**Future**:
- Unit tests for each module
- Integration tests with mock tools
- Template validation tests
- LLM response mocking

## Dependencies

**Core**:
- `tokio`: Async runtime
- `clap`: CLI parsing
- `serde`: Serialization
- `serde_yaml`: YAML parsing
- `reqwest`: HTTP for LLM APIs

**Utilities**:
- `anyhow`: Error handling
- `tracing`: Logging
- `colored`: Terminal colors
- `chrono`: Timestamps
- `libc`: Unix system calls

## Future Enhancements

1. **Parallel Execution**: Dependency-aware concurrent tool execution
2. **Template Dependencies**: `depends_on` field implementation
3. **Result Caching**: Avoid re-running identical scans
4. **Streaming Parsing**: Process large outputs incrementally
5. **Plugin System**: Dynamic tool loading
6. **Database Backend**: Store results in SQLite/PostgreSQL
7. **Web UI**: Dashboard for scan management
8. **Report Templates**: HTML/PDF report generation
9. **Notification System**: Slack/Email alerts on completion
10. **Multi-target Support**: Scan multiple targets concurrently
