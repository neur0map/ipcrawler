# .github/workflows/discord-notify.yml
name: Discord Commit Notifications

on:
  push:
    branches: [main, master, develop]
  pull_request:
    types: [opened, closed]

# least-privilege token
permissions:
  contents: read

# cancel older runs when a new push arrives on the same ref
concurrency:
  group: notify-${{ github.ref }}
  cancel-in-progress: true

env:
  # tweak this without touching the workflow:
  IMPORTANT_REGEX: '(feat|feature|perf|refactor|BREAKING CHANGE|chore\\(release\\)|release[: ]|\\bv?\\d+\\.\\d+\\.\\d+)'
  DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK_URL }}

jobs:
  notify-discord:
    if: github.event_name == 'push'
    runs-on: ubuntu-latest
    needs: [] # Will be populated if MegaLinter job exists

    steps:
      - name: Checkout (shallow)
        uses: actions/checkout@v4
        with:
          fetch-depth: 1            # minimal clone; we parse the event JSON instead of git log

      - name: Install jq
        run: sudo apt-get update && sudo apt-get -y install jq

      - name: Wait for and get MegaLinter results
        id: megalinter_status
        run: |
          # Try to get MegaLinter workflow results from this run
          WORKFLOW_RUN_ID="${{ github.run_id }}"
          
          echo "Checking for MegaLinter results in run: $WORKFLOW_RUN_ID"
          
          # Initialize status variables
          echo "megalinter_status=unknown" >> $GITHUB_OUTPUT
          echo "linter_summary=ðŸ”„ Quality analysis in progress" >> $GITHUB_OUTPUT
          echo "linter_emoji=ðŸ”„" >> $GITHUB_OUTPUT
          echo "linter_color=16776960" >> $GITHUB_OUTPUT
          
          # Wait up to 3 minutes for MegaLinter to complete
          max_attempts=18  # 18 * 10 seconds = 3 minutes
          attempt=1
          
          while [[ $attempt -le $max_attempts ]]; do
            echo "Attempt $attempt/$max_attempts: Checking MegaLinter status..."
            
            # Check if megalinter workflow exists and get results
            MEGALINTER_CONCLUSION=$(gh api "repos/${{ github.repository }}/actions/runs/$WORKFLOW_RUN_ID/jobs" --jq '.jobs[] | select(.name | contains("MegaLinter") or .name | contains("megalinter")) | .conclusion' 2>/dev/null | head -1)
            
            if [[ -n "$MEGALINTER_CONCLUSION" && "$MEGALINTER_CONCLUSION" != "null" ]]; then
              echo "MegaLinter completed with status: $MEGALINTER_CONCLUSION"
              
              if [[ "$MEGALINTER_CONCLUSION" == "success" ]]; then
                echo "megalinter_status=success" >> $GITHUB_OUTPUT
                echo "linter_summary=âœ… All quality checks passed" >> $GITHUB_OUTPUT
                echo "linter_emoji=âœ…" >> $GITHUB_OUTPUT
                echo "linter_color=3066993" >> $GITHUB_OUTPUT
                break
              elif [[ "$MEGALINTER_CONCLUSION" == "failure" ]]; then
                echo "megalinter_status=failure" >> $GITHUB_OUTPUT
                echo "linter_summary=âŒ Code quality issues detected" >> $GITHUB_OUTPUT
                echo "linter_emoji=âŒ" >> $GITHUB_OUTPUT
                echo "linter_color=15158332" >> $GITHUB_OUTPUT
                break
              fi
            else
              echo "MegaLinter job not found or still running (attempt $attempt)"
            fi
            
            # If it's the last attempt, proceed with pending status
            if [[ $attempt -eq $max_attempts ]]; then
              echo "MegaLinter did not complete within timeout, proceeding with pending status"
              break
            fi
            
            sleep 10
            ((attempt++))
          done
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Group commits and post to Discord
        env:
          EVT_PATH: ${{ github.event_path }}
        shell: bash
        run: |
          set -euo pipefail

          # ---------- split payload ----------
          echo "Processing GitHub event from: $EVT_PATH"
          echo "Total commits in push: $(jq -r '.commits | length' "$EVT_PATH")"
          
          mapfile -t IMPORTANT <<<"$(jq -cr --arg re "$IMPORTANT_REGEX" '.commits[] | select(.message | test($re;"i"))' "$EVT_PATH")"
          mapfile -t ROUTINE   <<<"$(jq -cr --arg re "$IMPORTANT_REGEX" '.commits[] | select(.message | test($re;"i") | not)' "$EVT_PATH")"
          
          echo "Important commits: ${#IMPORTANT[@]}"
          echo "Routine commits: ${#ROUTINE[@]}"

          # ---------- helper ----------
          send() {
            local json="$1"
            local code
            code=$(curl -s -o /dev/null -w '%{http_code}' -H 'Content-Type: application/json' -d "$json" "$DISCORD_WEBHOOK" || true)
            echo "Discord HTTP $code"
            sleep 1   # stay well under 30 reqs/min
          }

          # ---------- important commits ----------
          for row in "${IMPORTANT[@]}"; do
            # Extract basic commit info with fallbacks
            sha=$(jq -r '.id // "unknown"'      <<<"$row" | cut -c1-7)
            msg=$(jq -r '.message // "No message"' <<<"$row" | head -n1 | cut -c1-200)
            url=$(jq -r '.url // ""'     <<<"$row")
            who=$(jq -r '.author.name // .author.username // .committer.name // "Unknown"' <<<"$row")
            
            # Get file changes info with error handling
            files_added=$(jq -r '(.added // []) | length' <<<"$row" 2>/dev/null || echo "0")
            files_modified=$(jq -r '(.modified // []) | length' <<<"$row" 2>/dev/null || echo "0")
            files_removed=$(jq -r '(.removed // []) | length' <<<"$row" 2>/dev/null || echo "0")
            total_files=$((files_added + files_modified + files_removed))
            
            # Get actual changed files (limit to first 3)
            changed_files=$(jq -r '(.added // []) + (.modified // []) + (.removed // []) | .[0:3] | map("â€¢ `" + . + "`") | join("\n")' <<<"$row" 2>/dev/null || echo "â€¢ Files updated")
            if [[ -z "$changed_files" || "$changed_files" == "null" ]]; then
              changed_files="â€¢ Files updated"
            fi
            
            # Ensure we have a valid URL
            if [[ -z "$url" || "$url" == "null" ]]; then
              url="https://github.com/${{ github.repository }}/commit/$sha"
            fi
            
            # Debug output
            echo "Processing commit: $sha by $who"
            echo "Message: $msg"
            echo "URL: $url"
            echo "Files changed: $total_files"

            payload=$(jq -nc \
              --arg sha "$sha" \
              --arg msg "$msg" \
              --arg url "$url" \
              --arg who "$who" \
              --arg branch "${{ github.ref_name }}" \
              --arg total "$total_files" \
              --arg files "$changed_files" \
              --arg repo "${{ github.repository }}" \
              --arg linter_status "${{ steps.megalinter_status.outputs.linter_summary }}" \
              --arg linter_emoji "${{ steps.megalinter_status.outputs.linter_emoji }}" \
              --argjson linter_color "${{ steps.megalinter_status.outputs.linter_color }}" '
              {username:"ipcrawler-bot",
               embeds:[{
                 title:"ðŸ“¡ Intelligence Report: New Commit Deployed",
                 description:"**Target acquired:** `\($msg)`",
                 url:$url,
                 color:$linter_color,
                 fields:[
                   {name:"ðŸš© Operator", value:"`\($who)`", inline:true},
                   {name:"ðŸŒ Network Branch", value:"`\($branch)`", inline:true},
                   {name:"ðŸ” Scan Results", value:"`[\($sha)]`", inline:true},
                   {name:"ðŸ›°ï¸ Reconnaissance Data", value:"Mission parameters updated", inline:false},
                   {name:"ðŸ”§ Systems Updated (\($total) files):", value:$files, inline:false},
                   {name:"\($linter_emoji) Code Quality Analysis", value:$linter_status, inline:false}
                 ],
                 footer:{text:"ipcrawler reconnaissance framework â€¢ \($repo)"},
                 timestamp:(now|strftime("%Y-%m-%dT%H:%M:%SZ"))
               }]}')
            send "$payload"
          done

          # ---------- batch last â‰¤5 routine ----------
          if ((${#ROUTINE[@]})); then
            summary=""
            start=$(( ${#ROUTINE[@]} > 5 ? ${#ROUTINE[@]}-5 : 0 ))
            for ((i=start; i<${#ROUTINE[@]}; i++)); do
              sha=$(jq -r '.id'      <<<"${ROUTINE[$i]}" | cut -c1-7)
              msg=$(jq -r '.message' <<<"${ROUTINE[$i]}" | head -n1 | cut -c1-120)
              if [[ -n "$msg" ]]; then  # only add if message exists
                summary+=$'\n'"- \`$sha\`: $msg"
              fi
            done

            # Only send if we actually have content
            if [[ -n "$summary" ]]; then
              payload=$(jq -nc \
                --arg n "${#ROUTINE[@]}" \
                --arg s "$summary" \
                --arg branch "${{ github.ref_name }}" \
                --arg repo "${{ github.repository }}" \
                --arg linter_status "${{ steps.megalinter_status.outputs.linter_summary }}" \
                --arg linter_emoji "${{ steps.megalinter_status.outputs.linter_emoji }}" \
                --argjson linter_color "${{ steps.megalinter_status.outputs.linter_color }}" '
                {username:"ipcrawler-bot",
                 embeds:[{
                   title:"ðŸ“Š Intelligence Summary: Routine Operations (\($n))",
                   description:"**Operational status:** Background systems maintenance completed\($s)",
                   color:$linter_color,
                   fields:[
                     {name:"ðŸŒ Network Branch", value:"`\($branch)`", inline:true},
                     {name:"ðŸ“ˆ Mission Status", value:"âœ… All systems operational", inline:true},
                     {name:"\($linter_emoji) Code Quality Analysis", value:$linter_status, inline:false}
                   ],
                   footer:{text:"ipcrawler reconnaissance framework â€¢ \($repo)"},
                   timestamp:(now|strftime("%Y-%m-%dT%H:%M:%SZ"))
                 }]}')
              send "$payload"
            fi
          fi

  notify-pr:
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    steps:
      - name: Send PR notification
        env:
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK_URL }}
        shell: bash
        run: |
          set -euo pipefail
          action="${{ github.event.action }}"
          merged="${{ github.event.pull_request.merged }}"

          if   [[ "$action" == "opened" ]]; then color=3066993; emoji="ðŸ”€"; tag="opened"
          elif [[ "$action" == "closed" && "$merged" == "true" ]]; then color=5814783; emoji="âœ…"; tag="merged"
          elif [[ "$action" == "closed" ]]; then color=15158332; emoji="âŒ"; tag="closed"
          else color=16776960; emoji="ðŸ”„"; tag="$action"; fi

          payload=$(jq -nc \
            --arg title "$emoji Mission Status: Pull Request $tag" \
            --arg op "${{ github.event.pull_request.title }}" \
            --arg url "${{ github.event.pull_request.html_url }}" \
            --arg user "${{ github.event.pull_request.user.login }}" \
            --arg head "${{ github.event.pull_request.head.ref }}" \
            --arg base "${{ github.event.pull_request.base.ref }}" \
            --arg adds "${{ github.event.pull_request.additions }}" \
            --arg dels "${{ github.event.pull_request.deletions }}" \
            --argjson color "$color" '
            {username:"ipcrawler-bot",
             embeds:[{
               title:$title,
               description:"**Operation:** `\($op)`",
               url:$url,
               color:$color,
                                fields:[
                   {name:"ðŸŽ¯ Agent",        value:"`\($user)`", inline:true},
                   {name:"ðŸŒ Network Path", value:"`\($head)` â†’ `\($base)`", inline:true},
                   {name:"ðŸ“¡ Payload Size", value:"**[+] \($adds)** **[-] \($dels)**", inline:true}
                 ],
               timestamp:(now|strftime("%Y-%m-%dT%H:%M:%SZ"))
             }]}')
          curl -s -o /dev/null -H 'Content-Type: application/json' -d "$payload" "$DISCORD_WEBHOOK"